var express = require('express');
var path = require('path');
var graphqlHTTP = require('express-graphql');
var jwt = require('express-jwt');
const fileUpload = require('express-fileupload');
const auth = require('./utils/login');
const bodyParser = require('body-parser');
const globals = require('./config/globals');
const simpleExport = require('./utils/simple-export');
const execute = require('./utils/custom-graphql-execute');
const checkAuthorization = require('./utils/check-authorization');
const helper = require('./utils/helper');
const nodejq = require('node-jq')
const { JSONPath } = require('jsonpath-plus');
const errors = require('./utils/errors');
const { formatError } = require('graphql');

var acl = null;

var cors = require('cors');

/* Server */
const APP_PORT = globals.PORT;
const app = express();

app.use((req, res, next) => {
  // Website you wish to allow to connect
  if (globals.REQUIRE_SIGN_IN) {
    res.setHeader('Access-Control-Allow-Origin', globals.ALLOW_ORIGIN);
  }
  next();
});

// Force users to sign in to get access to anything else than '/login'
console.log("REQUIRE: ", globals.REQUIRE_SIGN_IN);
if (globals.REQUIRE_SIGN_IN) {
  app.use(jwt({ secret: 'something-secret' }).unless({ path: ['/login'] }));
}

/* Temporary solution:  acl rules set */
if (process.argv.length > 2 && process.argv[2] == 'acl') {
  let node_acl = require('acl');
  let {
    aclRules
  } = require('./acl_rules');
  let acl = new node_acl(new node_acl.memoryBackend());

  /* set authorization rules from file acl_rules.js */
  acl.allow(aclRules);
  console.log("Authoization rules set!");

} else {
  console.log("Open server, no authorization rules");
}

/* Schema */
console.log('Merging Schema');
let Schema = helper.mergeSchemaSetScalarTypes(path.join(__dirname, './schemas'));


/* Resolvers*/
let resolvers = require('./resolvers/index');
const { leftShift } = require('mathjs');


/* Parse urlencoded bodies and JSON by bodyParser middlewares*/
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json({ limit: globals.POST_REQUEST_MAX_BODY_SIZE }));

app.use('/login', cors(), async (req, res) => {
  try {
    const token = await (auth.login(req.body))
    res.json({ token: token })
  } catch (err) {
    res.status(500).send({ error: `${err}. Please check your credentials.` })
  }
});

app.use('/export', cors(), async (req, res) => {
  //set checker for using in the local method simpleExport
  res['responseSent'] = false;

  //set MAX_TIME_OUT
  res.setTimeout(globals.EXPORT_TIME_OUT * 1000, function () {
    res.end("TIMEOUT EXCEEDS");
  });

  res.on('finish', () => {
    res['responseSent'] = true;
  });

  let context = {
    request: req,
    acl: acl,
    benignErrors: [],
    recordsLimit: globals.LIMIT_RECORDS
  }

  let body_info = req.query;

  try {
    await simpleExport(context, body_info, res);
    res.end();
  } catch (err) {
    if (!res.responseSent) {
      res.status(500).send(err);
    } else {
      console.error("ERROR IN EXPORT AFTER SENDING THE RESPONSE: " + err);
    }
  }
});

app.use(fileUpload());
/*request is passed as context by default  */
app.use('/graphql', cors(), graphqlHTTP((req) => ({
  schema: Schema,
  rootValue: resolvers,
  pretty: true,
  graphiql: true,
  context: {
    request: req,
    acl: acl,
    benignErrors: [],
    recordsLimit: globals.LIMIT_RECORDS
  },
  customExecuteFn: execute.execute,
  customFormatErrorFn: function (error) {
    errors.customErrorLog(error) // Will log the error either compact (defualt) or verbose dependent on the env variable "ERROR_LOG"
    let extensions = errors.formatGraphQLErrorExtensions(error);
    return {
      message: error.message,
      locations: error.locations ? error.locations : "",
      // Either use the extensions of a remote error, or
      // the local originalError.errors generated by for example validation Errors (AJV):
      extensions: extensions,
      path: error.path
    };

  }
})));

let metaQueryCorsOptions = {allowedHeaders: ['Content-Type', 'Authorization']};
app.options("/meta_query", cors(metaQueryCorsOptions));
app.post('/meta_query', cors(), async (req, res, next) => {
  try {
    let context = {
      request: req,
      acl: acl,
      benignErrors: [],
      recordsLimit: globals.LIMIT_RECORDS
    }

    if (req != null) {
      if (await checkAuthorization(context, 'meta_query', '') === true) {
        let queries = req.body.queries;
        let jq = req.body.jq;
        let jsonPath = req.body.jsonPath;
        helper.eitherJqOrJsonpath(jq, jsonPath);

        if (!Array.isArray(queries)) {
          let newQueries = [queries];
          queries = newQueries;
        }

        let graphQlResponses = await helper.handleGraphQlQueriesForMetaQuery(Schema, resolvers, queries, context);
        let output = null;

        if (helper.isNotUndefinedAndNotNull(jq)) { // jq
          output = await nodejq.run(jq, graphQlResponses, { input: 'json', output: 'json' }).catch((err) => {throw err});
        } else { // JSONPath
          output = JSONPath({ path: jsonPath, json: graphQlResponses, wrap: false });
        }
        res.json(output);
        next();
      } else {
        throw new Error("You don't have authorization to perform this action");
      }
    }
  } catch (error) {
    res.json({ data: null, errors: [formatError(error)] });
  }
});
/**
 * uncaughtException handler needed to prevent node from crashing upon receiving a malformed jq filter.
 */
process.on('uncaughtException', err => {console.log("!!uncaughtException:", err)});

// Error handling
app.use(function (err, req, res, next) {
  if (err.name === 'UnauthorizedError') { // Send the error rather than to show it on the console
    res.status(401).send(err);
  }
  else {
    next(err);
  }
});

var server = app.listen(APP_PORT, () => {
  console.log(`App listening on port ${APP_PORT}`);
});

module.exports = server;
