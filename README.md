# Zendro GraphQL Server

Skeleton NodeJS project for a graphQL server.

This package provides a scaffold to be completed with contents generated by the [code-generator](https://github.com/Zendro-dev/graphql-server-model-codegen).

## Set up

Clone the repository and use the [Code-generator](https://github.com/ScienceDb/graphql-server-model-codegen) to dynamically generate the contents of four folders with the models information:

* models
* schemas
* resolvers
* migrations

After getting ready the generated code for the models, proceed with the server set up.

```sh
$ npm install
$ bash migrateDbAndStartServer.sh
$ npm start
```

The script ```$ migrateDbAndStartServer.sh``` will create the tables specified in the ```migrations``` folder of each database configuration, using the credentials specified in ```config/data_models_storage_config.json``` file.

_NOTE: Databases should be already configured locally in `config/data_models_storage_config.json`_.


## Environment Variables

### Mandatory
* `ALLOW_ORIGIN` - Sets the `Access-Control-Allow-Origin` header to the specified value.
* `JWT_SECRET` - The secret string used to sign authorization tokens.

### Optional (without defaults)
* `MAIL_SERVICE` - For bulk add operations, the email service to use for sending progress reports.
* `MAIL_HOST` - Email service host (usually SMTP config).
* `MAIL_ACCOUNT` - Sender email account address.
* `MAIL_PASSWORD` - Sender email account password.

### Optional (with sensible defaults)
* `ERROR_LOG` - Debug logs verbosity. Can be either "verbose" or "compact". Default value is `compact`.
* `EXPORT_TIME_OUT` - Maximum amount of time in milliseconds before the server throws a timeout error when exporting data. Default is `3600`.
* `LIMIT_RECORDS` - Maximum number of records that each request can return, default value is `10000`.
* `PORT` - The port where the app is listening, default value is `3000`
* `POST_REQUEST_MAX_BODY_SIZE` - Maximum size of the GraphQL request in MB. Default is `1mb`.
* `MAX_TIME_OUT` - Maximum number of milliseconds that a zendro server will wait to connect with another zendro server. Default value is `2000`.
* `REQUIRE_SIGN_IN` - Boolean to toggle the required sign in to the graphql server. Default is `true`.
* `SALT_ROUNDS` - Number of salt rounds when hashing a new password. Default is `10`.



## Examples

If you followed the example for generating the code described [here](https://github.com/ScienceDb/graphql-server-model-codegen), you can try the next queries and mutations. Otherwise, just adapt the same queries and mutations for your own models generated.

We will add the next 4 people to our table ``people``.

Name (firstName) | Last Name (lastName) | Email (email)
---              | ---                  | ---
Albert           | Einstein             | albert.einstein@science.com
Thomas           | Edison               | thomas.edison@science.com
Vincent          | van Gogh             | vicent.vanGogh@art.com
Ludwig           | Beethoven            | ludwing.beethoven@art.com

#### CREATE PERSON

```
curl -XPOST http://localhost:3000/graphql -H 'Content-Type: application/graphql' -d 'mutation M { addPerson(firstName: "Albert", lastName: "Einstein", email: "albert.einstein@science.com"){ firstName email } }'
```
As result we will get `firsName` and `email` of the person just created:

```json
{
  "data": {
    "addPerson": {
      "firstName": "Albert",
      "email": "albert.einstein@science.com"
    }
  }
}
```
In the same way we add the next 3 people:

```sh
curl -XPOST http://localhost:3000/graphql -H 'Content-Type: application/graphql' -d 'mutation M { addPerson(firstName: "Thomas", lastName: "Edison", email: "thomas.edison@science.com") { firstName email } }'

curl -XPOST http://localhost:3000/graphql -H 'Content-Type: application/graphql' -d 'mutation M { addPerson(firstName: "Vicent", lastName: "van Gogh", email: "vicent.vanGogh@art.com"){ firstName email } }'

curl -XPOST http://localhost:3000/graphql -H 'Content-Type: application/graphql' -d 'mutation M { addPerson(firstName: "Ludwig", lastName: "Beethoven", email: "ludwig.beethoven@art.com"){ firstName email } }'
```

#### SEARCH PEOPLE WITH FILTER

We'll search people with 'science' as substring of their email and as result we'll get only their name and last name.

```
curl -XPOST http://localhost:3000/graphql -H 'Content-Type: application/graphql' -d '{ people(search:{field:email, value:{value:"%science%"}, operator:like}){ firstName lastName}}'
```
The result will be:

```json
{
  "data": {
    "searchPerson": [
      {
        "firstName": "Albert",
        "lastName": "Einstein"
      },
      {
        "firstName": "Thomas",
        "lastName": "Edison"
      }
    ]
  }
}
```
